# 기본 타입과 레퍼런스 타입

## 데이터 타입

- 원시(기본) 타입
  - 숫자
  - 문자열
  - 불린
  - undefined
  - null
  - Symbol
- 참조(레퍼런스) 타입
  - object
    - array
    - function
    - regexp
    - date

## 복사

### 기본 타입

```javascript
var a = 10;
b = a;

console.log(a); // 10
console.log(b); // 10

b = 12;
console.log(a); // 10
console.log(b); // 12
```

### 레퍼런스 타입

```javascript
var obj = { name: 'ryu' };
obj2 = obj;

console.log(obj); // { name: 'ryu' }
console.log(obj2); // { name: 'ryu' }

obj2.name = 'han';
console.log(obj); // { name: 'han' }
console.log(obj2); // { name: 'han' }
```

레퍼런스 타입의 경우 원본이 변경되는 경우 사본에 영향을 주게 된다. 이러한 작동 방식을 원치 않는다면 기존 상태로 새로운 객체를 만들어서 반환하면 된다.

#### 배열

```javascript
// 기존 상태에 영향을 주는 경우
var arr = [1, 2, 3];
	temp = arr;

temp.push(4);

console.log(arr); // [1, 2, 3, 4]
console.log(temp); // [1, 2, 3, 4]

// 기존 상태에 영향을 주지 않고 새로운 배열 반환
var arr = [1, 2, 3],
    temp = arr;

temp = temp.concat(4);

console.log(arr); // [1, 2, 3]
console.log(temp); // [1, 2, 3, 4]
```

#### 객체

```javascript
// 기존 상태에 영향을 주는 경우
var obj = { name: 'ryu' };
obj2 = obj;

console.log(obj); // { name: 'ryu' }
console.log(obj2); // { name: 'ryu' }

obj2.name = 'han';

console.log(obj); // { name: 'han' }
console.log(obj2); // { name: 'han' }

// 기존 상태에 영향을 주지 않고 새로운 객체 반환
var obj = { name: 'ryu' };
obj2 = Object.assign({}, obj);

console.log(obj); // { name: 'ryu' }
console.log(obj2); // { name: 'ryu' }

obj2.name = 'han';

console.log(obj); // { name: 'ryu' }
console.log(obj2); // { name: 'han' }
```

## 매개변수 전달

함수 매개변수에 기본타입과 레퍼런스를 전달하는 경우도 위와 같은 문제점이 발생하므로 이를 정확히 인지하고 활용하자.

```javascript
// 기존 상태에 영향을 주는 경우
function A(obj) {
    obj.name = 'han';
}

var obj = { name: 'ryu' };
obj2 = obj;

console.log(obj); // { name: 'ryu' }
console.log(obj2); // { name: 'ryu' }

A(obj2);

console.log(obj); // { name: 'han' }
console.log(obj2); // { name: 'han' }
```



